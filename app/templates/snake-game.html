<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <title>Simple Canvas Game</title>
    <style>
        #gameCanvas {
            display: block;
            margin: auto;
        }
    </style>
</head>
<body>
    {% include 'header.html' %}
    <canvas id="gameCanvas" width="800" height="800"></canvas>

    <script>
        // Get a reference to the canvas element
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const Direction = {
            UP: 'UP',
            DOWN: 'DOWN',
            LEFT: 'LEFT',
            RIGHT: 'RIGHT'
        };
        const playPauseText = "Press Space To Play or Pause"
        const controlsText = "WASD or Arrow Keys to Move"
        const boostText = "B or Left Shift to boost, you can pass through yourself if you time it right"
        const gameOverText = "Game Over, Your Score: "
        let colour = 255
        // Define player position
        let playerX = canvas.width/2;
        let playerY = canvas.height/2;
        let playerArr = []
        let direction = NaN;
        let acceptInput = true
        let speed = 10;
        let snakeSize = 10;
        let baitX = 0;
        let baitY = 0;
        setBaitCoordinates()
        let playerSize = 1;
        let playerScore = 0;
        let startGame = false;
        let gameOver = false;
        let pauseGame = false;
        let lastFrameTime = 0;
        const frameDelay = 1000 / 25;

        //no need for this since snake moves 10 pixels per draw
        function normalizeCoordinates(normX, normY) {
        if (normX % 10 > 6) {
            normX = parseInt(((normX / 10) + 1)) * 10;
        } else normX = parseInt(normX / 10) * 10;
        if (normY % 10 > 6) {
            normY = parseInt(((normY / 10) + 1))* 10;
        } else normY = parseInt(normY / 10) * 10;
        return [normX, normY];
        }

        function setBaitCoordinates() {
        baitX = parseInt(((Math.random() * (canvas.width - 60)) + 20) / 10) * 10;
        baitY = parseInt(((Math.random() * (canvas.height - 60)) + 20) / 10) * 10;
        }

        // Main game loop
        function gameLoop() {

            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;

            if (deltaTime > frameDelay) {
                lastFrameTime = currentTime;
                if(startGame){

                    if (pauseGame){
                        renderPause()
                    }
                    else{
                        if (baitX === playerX && baitY === playerY){
                            playerSize += 1;
                            setBaitCoordinates();
                        }
                        if (direction === Direction.UP && playerY > 20){
                            playerY -= speed;
                            acceptInput = true;
                        }
                        if (direction === Direction.DOWN && playerY < canvas.height - 30){
                            playerY += speed;
                            acceptInput = true;
                        }
                        if (direction === Direction.LEFT && playerX > 20){
                            playerX -= speed;
                            acceptInput = true;
                        }
                        if (direction === Direction.RIGHT && playerX < canvas.width - 30){
                            playerX += speed;
                            acceptInput = true;
                        }
                        const collisionIndex = playerArr.findIndex(c => c[0] === playerX && c[1] === playerY);
                        if (collisionIndex !== -1) {
                            playerScore = playerSize
                            playerSize = playerSize - Math.ceil(collisionIndex/snakeSize)
                            if (playerSize <= 0){
                                startGame = false
                                gameOver = true
                            }
                            playerArr.splice(0,collisionIndex);
                        }
                        if (playerArr.length > playerSize * snakeSize){
                            playerArr.shift();
                        }
                        //playerArr.push(normalizeCoordinates(playerX,playerY));//to get a clear snake line,needs revision
                        playerArr.push([playerX,playerY]);//to get more fluid snake line

                        render();
                    }
                    
                }
                else{
                    if(gameOver){
                        renderGameOver();
                    }
                    else {
                        renderMenu();
                    playerX = canvas.width/2;
                    playerY = canvas.height/2;
                    playerArr = [];
                    direction = NaN;
                    speed = 10;
                    snakeSize = 10;
                    setBaitCoordinates();
                    playerSize = 1;
                    }
                }
            }
            requestAnimationFrame(gameLoop);
        }

        // Function to render the game state
        function render() {
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'gray';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = 'green';
            ctx.fillRect(25,25,canvas.width-50,canvas.height-50);
            ctx.fillStyle = 'blue';
            ctx.fillRect(baitX, baitY, 10, 10);
            let snakeParts = 0;
            const lastIndex = playerArr.length - 1;
            playerArr.forEach(function(e) {
                ctx.beginPath();
                ctx.arc(e[0]+5, e[1]+5, 5, 0, Math.PI * 2);
                if(snakeParts==lastIndex){
                    ctx.fillStyle = 'black';
                }
                else{
                    let hue = ((playerSize - Math.floor(((snakeParts))/10)-1)*12)%360;
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                }
                snakeParts+=1;
                ctx.fill();
                ctx.closePath();
            });
            ctx.font = '20px Arial';
            ctx.fillStyle = 'black';
            ctx.fillText(playerSize,canvas.width/2,20)
        }

        function renderMenu(){
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'gray';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.font = '20px Arial';
            ctx.fillStyle = 'black';
            ctx.fillText(playPauseText,(canvas.width-ctx.measureText(playPauseText).width)/2,canvas.height/2-30)
            ctx.fillText(controlsText,(canvas.width-ctx.measureText(controlsText).width)/2,canvas.height/2)
            ctx.fillText(boostText,(canvas.width-ctx.measureText(boostText).width)/2,canvas.height/2+30)

        }
        function renderPause(){

        }
        function renderGameOver(){
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'gray';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.font = '20px Arial';
            ctx.fillStyle = 'black';
            ctx.fillText(`${gameOverText} ${playerScore}`,(canvas.width-ctx.measureText(`${gameOverText} ${playerScore}`).width)/2,canvas.height/2)
        }
        gameLoop();

        document.addEventListener('keydown', function(event) {

            if ((event.key == 'ArrowUp' || event.key.toUpperCase() == 'W') && direction!= Direction.DOWN && direction!=Direction.UP && acceptInput)  {
                direction = Direction.UP
                const normArr = [playerX,playerY]
                playerX = normArr[0]
                playerY = normArr[1]
                acceptInput = false
            }
            if ((event.key == 'ArrowDown'|| event.key.toUpperCase()  == 'S')&& direction!= Direction.DOWN && direction!=Direction.UP && acceptInput){
                direction = Direction.DOWN
                const normArr = [playerX,playerY]
                playerX = normArr[0]
                playerY = normArr[1]
                acceptInput = false
            }
            if ((event.key == 'ArrowLeft'|| event.key.toUpperCase()  == 'A')&& direction!= Direction.LEFT && direction!=Direction.RIGHT && acceptInput){
                direction = Direction.LEFT
                const normArr = [playerX,playerY]
                playerX = normArr[0]
                playerY = normArr[1]
                acceptInput = false
            }
            if ((event.key == 'ArrowRight'|| event.key.toUpperCase()  == 'D')&& direction!= Direction.LEFT && direction!=Direction.RIGHT && acceptInput){
                direction = Direction.RIGHT
                const normArr = [playerX,playerY]
                playerX = normArr[0]
                playerY = normArr[1]
                acceptInput = false
            }

            if (event.key == ' ' && startGame == true){
                if (pauseGame){
                    pauseGame = false
                }
                else{
                    pauseGame = true
                }
            }


            if (event.key == ' ' && startGame == false && gameOver == false){
                startGame = true
                direction = Direction.RIGHT
            }

            if (event.key == ' ' && startGame == false && gameOver){
                gameOver = false
            }

            if (event.key.toLowerCase() == 'b' || event.code == 'ShiftLeft'){
                speed = 20;
            }

        });
        document.addEventListener('keyup', function(event) {
            if (event.key.toLowerCase() == 'b' || event.code == 'ShiftLeft'){
                speed = 10;
            }
        });
    </script>
    {% include 'footer.html' %}
</body>
</html>
